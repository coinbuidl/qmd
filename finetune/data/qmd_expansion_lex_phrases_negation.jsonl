{"query": "performance optimization C++ program", "intent": "optimizing a C++ application", "output": [["lex", "\"C++ performance\" optimization -sports -athlete"], ["lex", "\"memory allocation\" \"cache miss\" profiling"], ["vec", "how to improve the runtime performance of a C++ program"], ["hyde", "C++ performance optimization involves profiling with tools like perf or valgrind, reducing memory allocations, improving cache locality, and avoiding unnecessary copies. Key techniques include move semantics, reserve on vectors, and SIMD intrinsics for hot loops."]]}
{"query": "python memory leak debugging", "intent": "debugging a Python application", "output": [["lex", "\"memory leak\" python -java -javascript"], ["lex", "\"garbage collector\" reference counting tracemalloc"], ["vec", "how to find and fix memory leaks in a Python application"], ["hyde", "Python memory leaks often occur when objects hold references longer than expected, preventing garbage collection. Use tracemalloc or memory_profiler to track allocations over time. Common causes include circular references, global caches, and event listeners that aren't removed."]]}
{"query": "connection pool exhaustion database", "intent": "debugging database connectivity issues", "output": [["lex", "\"connection pool\" exhausted timeout -redis -cache"], ["lex", "\"max connections\" database pool overflow"], ["vec", "why does the database connection pool run out of connections under load"], ["hyde", "Connection pool exhaustion occurs when all connections are checked out and new requests must wait or fail. This typically happens when queries run slowly, connections aren't released properly, or traffic spikes beyond pool capacity. Fix by increasing pool size, setting connection timeouts, or optimizing slow queries."]]}
{"query": "rate limiting API implementation", "intent": "implementing rate limiting in a backend service", "output": [["lex", "\"rate limit\" \"token bucket\" OR \"sliding window\" -ethereum -cryptocurrency"], ["lex", "\"requests per second\" throttle middleware"], ["vec", "how to implement rate limiting for an API endpoint"], ["hyde", "A token bucket rate limiter grants each client N tokens per time window. Each request consumes one token. When tokens run out, requests are rejected with 429 Too Many Requests. Tokens refill at a fixed rate. This allows short bursts while enforcing long-term average rate limits."]]}
{"query": "SQL query performance slow", "intent": "optimizing a slow database query", "output": [["lex", "\"query plan\" index scan \"full table\" slow -nosql -mongodb"], ["lex", "\"missing index\" \"N+1\" joins optimization"], ["vec", "why is my SQL query running slowly and how do I optimize it"], ["hyde", "Slow SQL queries are usually caused by missing indexes, full table scans, or N+1 query patterns. Use EXPLAIN ANALYZE to view the query plan. Add indexes on columns used in WHERE, JOIN, and ORDER BY clauses. Avoid SELECT * and fetch only the columns needed."]]}
{"query": "machine learning model overfitting", "intent": "training a machine learning model", "output": [["lex", "\"overfitting\" \"validation loss\" regularization -sports -fitness"], ["lex", "dropout \"weight decay\" \"early stopping\" training"], ["vec", "how to detect and prevent overfitting in a machine learning model"], ["hyde", "Overfitting occurs when a model memorizes training data instead of learning generalizable patterns, leading to high training accuracy but poor validation performance. Prevention techniques include dropout, L1/L2 regularization, data augmentation, and early stopping based on validation loss."]]}
{"query": "docker container networking", "intent": "configuring Docker networking", "output": [["lex", "\"docker network\" bridge overlay -kubernetes -k8s"], ["lex", "\"container ip\" \"port mapping\" expose publish"], ["vec", "how do Docker containers communicate with each other on the same host"], ["hyde", "Docker containers on the same host communicate via bridge networks. By default, containers on the bridge network can reach each other by IP. Use docker network create to make named networks, then --network flag to attach containers. Services can reference each other by container name as DNS hostname."]]}
{"query": "authentication token JWT", "intent": "implementing JWT authentication", "output": [["lex", "\"JWT\" \"json web token\" \"secret key\" -oauth -saml"], ["lex", "\"bearer token\" signature expiry claims"], ["vec", "how does JWT authentication work and how do I validate a token"], ["hyde", "JWT tokens consist of three base64-encoded parts: header (algorithm), payload (claims like user id and expiry), and signature. The server validates the signature using a secret key and checks that the token hasn't expired. Never store sensitive data in the payload as it's only encoded, not encrypted."]]}
{"query": "async await error handling javascript", "intent": "writing async JavaScript code", "output": [["lex", "\"async\" \"await\" \"try catch\" promise -python -rust"], ["lex", "\"unhandled rejection\" \"error boundary\" async"], ["vec", "how to properly handle errors in async/await JavaScript functions"], ["hyde", "Wrap await calls in try/catch blocks to handle rejections. Unhandled promise rejections crash Node.js processes. For parallel operations, use Promise.allSettled() instead of Promise.all() to handle partial failures. Always chain .catch() or use try/catch â€” never leave promises floating."]]}
{"query": "git merge conflict resolution", "intent": "resolving a git merge conflict", "output": [["lex", "\"merge conflict\" \"<<<<<<\" rebase resolution -github -gitlab"], ["lex", "\"conflict markers\" \"ours\" \"theirs\" checkout"], ["vec", "how do I resolve a git merge conflict between two branches"], ["hyde", "Git merge conflicts occur when two branches change the same lines. Conflict markers show both versions: <<<<<<< HEAD (your changes), ======= (separator), and >>>>>>> branch-name (incoming). Edit the file to keep the correct version, remove the markers, then git add and git commit to complete the merge."]]}
{"query": "kubernetes pod crashloopbackoff", "intent": "debugging a Kubernetes deployment", "output": [["lex", "\"CrashLoopBackOff\" pod logs restart -docker -vagrant"], ["lex", "\"container failed\" liveness probe startup"], ["vec", "why is my Kubernetes pod stuck in CrashLoopBackOff and how do I fix it"], ["hyde", "CrashLoopBackOff means the container keeps crashing and Kubernetes is backing off restarts exponentially. Check logs with kubectl logs --previous to see the last crash output. Common causes: misconfigured environment variables, missing secrets, failed liveness probes, or an application crash on startup."]]}
{"query": "react state management redux", "intent": "managing state in a React application", "output": [["lex", "\"Redux\" \"useReducer\" \"action creator\" -angular -vue"], ["lex", "\"store dispatch\" \"selector\" \"middleware\" thunk"], ["vec", "when should I use Redux versus local React state for state management"], ["hyde", "Redux is best for state shared across many components or that needs to persist across routes. Local useState is fine for UI state scoped to one component. For medium complexity, useContext + useReducer avoids Redux boilerplate. Redux shines for large apps with complex update logic, time-travel debugging, or middleware needs."]]}
